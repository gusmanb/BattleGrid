REM @options --asm --array-base 1 --string-base 1 --optimize 4 --org 24750 --heap-size 128 --explicit --strict -D HIDE_LOAD_MSG

#define PRECOMPUTED_SPRITES
#define ENABLE_PRINT

#define ENABLE_1x1_SPRITES
'#define ENABLE_1x2_SPRITES
'#define ENABLE_2x2_SPRITES

'Total number of 1x1 defined sprites
#define TOTAL_1x1_SPRITES 16
'Total number of 1x2 defined sprites
#define TOTAL_1x2_SPRITES 0
'Total number of 2x2 defined sprites
#define TOTAL_2x2_SPRITES 0

'Maximum on-screen 1x1 sprites
#define ONSCREEN_1x1_SPRITES 10
'Maximum on-screen 1x2 sprites
#define ONSCREEN_1x2_SPRITES 0
'Maximum on-screen 2x2 sprites
#define ONSCREEN_2x2_SPRITES 0

'If defined enables the tile system in its basic mode (tiles erased when sprite enters on it)
#define ENABLE_TILES
'If defined tiles are merged with OR instead of erased
'Requires ENABLE_TILES
#define MERGE_TILES

'The lib by default disables interrupts, enabling this option
'will reactivate them after each call to the lib
#define ENABLE_INTERRUPTS

#include "GuSprites.zxbas"
#include <keys.bas>
#include "FastRND.zxbas"
#include "BeepFX.zxbas"
#include "InterruptInstaller.zxbas"
#include "DefinesAndMacros.zxbas"
#include "KeyManager.zxbas"
'#include "MusicPlayer.zxbas"

vars:
Dim playerX as uByte = 20
Dim playerSprite as uByte = 0
Dim score as uInteger
Dim updateScore as uByte = 0
Dim lifes as uByte = 4

Dim dir as byte = 0
Dim dead as ubyte = 0           '1 = muerte por disparo, 2 = muerte por tanque, 3 = muerte por alien

Dim shots(3,4) as Byte         'x,y,dir,explodePhase
Dim activeShots as uByte

Dim cursorX as uByte = 0
Dim cursorY as uByte = 0
Dim cursorVisible as uByte = 0
Dim cursorFrames as uByte = CURSOR_FRAMES
Dim cursorMoved as uByte = 0
Dim cursorTool as uByte = TOOL_NONE

dim level as uByte

Dim activeMap(20, 20) as uByte

'WARNING!! Path map is y/x not x/y and has an empty border
Dim pathMap(22, 22) as ubyte


Dim reflectDirsA(4) as uByte => { 2, 4, 1, 3 }
Dim reflectDirsB(4) as uByte => { 4, 1, 2, 3 }
Dim reflectDirsC(4) as uByte => { 2, 3, 4, 1 }
Dim reflectDirsD(4) as uByte => { 3, 1, 4, 2 }

Dim maskTable(8) as uByte => { 1, 2, 4, 8, 16, 32, 64, 128  }
Dim bitTable(8) as uByte => { 1, 3, 7, 15, 31, 63, 127, 256  }

Dim aliens(MAX_ALIEN_COUNT,4) as Byte         'x,y,dir,explodePhase
Dim activeAliens as uByte
Dim alienFrame as uByte = ALIEN_SPEED

Dim tanks(MAX_TANK_COUNT,4) as Byte         'x,y,dir,explodePhase
Dim activeTanks as uByte
Dim tankFrame as uByte = TANK_SPEED
Dim tankProbability as uByte

Dim activeTowers as uByte 

Dim availableMines as uByte = 0
Dim availableBombs as uByte = 0
Dim availableBlockers as uByte = 0
Dim availableChargedShots as uByte = 0
Dim availableFireShots as uByte = 0
Dim availableClearShots as uByte = 0


Dim activeShips as uByte
Dim ships(MAX_SHIP_COUNT,4) as uByte 'x,y,dir,frame
Dim freezingShip as uByte = 1
Dim shipIndexes(MAX_SHIP_COUNT * 2) as uByte

Dim activeHangars as uByte
Dim hangars(MAX_HANGAR_COUNT,4) as uByte 'x,y,dir,frame
Dim freezingHangar as uByte = 1
Dim hangarIndexes(MAX_SHIP_COUNT * 2) as uByte

Dim refreshMap as uByte = 0

Dim destructibles(MAX_DESTRUCTIBLES_COUNT,2) as uByte
Dim activeDestructibles as uByte

Dim fires(MAX_ACTIVE_FIRES, 3) as uByte
Dim activeFires as uByte

init:


#include "ZoomAnims.zxbas"
#include "Tools.zxbas"
#include "MapLoader.zxbas"

InstallHandler()
InitFastRnd()

funcs:

sub InitGraphics()

    InitGFXLib()
    SetTileset(@tileSet)

end sub


sub AddScore(ScoreToAdd as uinteger)
    score = score + ScoreToAdd
    updateScore = 1
end sub

sub ShowLifes()

    Dim buc as uByte

    for buc = 1 to 4
        if lifes >= buc then
            SetTile(LIFE_INDEX, tileColors(LIFE_INDEX + 1), 22 + (buc << 1), 22)
        else
            SetTile(EMPTY_TILE_INDEX, 0, 22 + (buc << 1), 22)
        end if
    next buc        

end sub


sub PrintPaddedNumber(x as ubyte, y as ubyte, value as uinteger, length as ubyte)

    Dim strnum as string = str$(value)

    Dim tmpVal as uByte = len(strnum)

    if tmpVal >= length then 
        strnum = strnum(1 TO length)
    else
         Dim lp as uByte

        for lp = 1 to (length - tmpVal)
            strnum = "0" + strnum
        next lp
    end if

    for tmpVal = 1 to length

        PrintDigit(x + tmpVal - 1, y, code(strnum(tmpVal to tmpVal)) - 48)

    next tmpVal

end sub

sub InitInterface()

    ClearScreen(CREATE_ATTRIB(7,0,0,0))

    Dim tmpX as uByte

    ShowLogo(23, 2)

    SetTile(BLOCKER_INDEX, tileColors(BLOCKER_INDEX + 1), 24, 16)
    SetTile(MINE_INDEX, tileColors(MINE_INDEX + 1), 28, 16)
    SetTile(BOMB_INDEX, tileColors(BOMB_INDEX + 1), 24, 18)
    SetTile(CHARGEDSHOT_INDEX, tileColors(CHARGEDSHOT_INDEX + 1), 28, 18)
    SetTile(FIRESHOT_INDEX, tileColors(FIRESHOT_INDEX + 1), 24, 20)
    SetTile(CLEARSHOT_INDEX, tileColors(CLEARSHOT_INDEX + 1), 28, 20)

    for tmpX = 16 to 20 step 2
        PrintString(":", CREATE_ATTRIB(7, 0, 1, 0), 25, tmpX)
        PrintString(":", CREATE_ATTRIB(7, 0, 1, 0), 29, tmpX)
    next tmpX

    PrintString("LEVEL:", CREATE_ATTRIB(7, 0, 1, 0), 24, 7)
    PrintString("SCORE:", CREATE_ATTRIB(7, 0, 1, 0), 24, 10)
    PrintString("SAT:", CREATE_ATTRIB(7, 0, 1, 0), 24, 13)

end sub

sub InitLevel()

    Dim tmpX as uByte
    Dim tmpY as uByte

    for tmpX = 1 to 20
        for tmpY = 1 to 19
            activeMap(tmpX, tmpY) = 0
        next tmpY
    next tmpX

    activeShots = 0
    activeAliens = 0
    activeTanks = 0
    activeShips = 0
    activeHangars = 0
    activeTowers = 0
    activeDestructibles = 0
    availableBlockers = 0
    availableBombs = 0
    availableMines = 0
    availableChargedShots = 0
    availableClearShots = 0
    availableFireShots = 0
    freezingShip = 1
    freezingHangar = 1
    cursorTool = TOOL_NONE
    cursorX = 0
    cursorY = 0
    cursorFrames = CURSOR_FRAMES
    cursorVisible = 0

    for tmpX = 26 to 30 step 4
        for tmpY = 16 to 20 step 2
            PrintDigit(tmpX, tmpY, 0)
        next tmpY
    next tmpX

    playerX = 20
    dead = 0
    tankProbability = 128

    
    PrintPaddedNumber(24, 8, level, 2)
    updateScore = 0
    PrintPaddedNumber(24, 11, score, 6)

    PrintString("NONE   ", CREATE_ATTRIB(7, 0, 1, 0), 24, 14)

    shots(1,4) = -1
    shots(2,4) = -1
    shots(3,4) = -1

    LoadMap(level)

    ShowLifes()

    PathFind(10,20)

end sub

sub UpdatePlayer()

    if dead <> 0 then return

    playerSprite = PLAYER_INDEX

    if MultiKeys(KEYZ) then
        dir = -1
        playerSprite = PLAYERLEFT_INDEX
        if playerX > 2 then playerX = playerX - 1
    else if MultiKeys(KEYC)
        dir = 1
        playerSprite = PLAYERRIGHT_INDEX
        if playerX < 40 then playerX = playerX + 1
    else if MultiKeys(KEY0)
        dead = 3
    else
        if playerX & 1 = 0 then
            dir = 0
            playerSprite = PLAYER_INDEX
        else
            playerX = playerX + dir
        end if
    end if
end sub

sub CheckShotItems(shotIndex as uByte, cellX as uByte, cellY as uByte)

    Dim tmpX as uByte
    Dim tmpY as uByte
    Dim tmpDir as uByte

    if activeMap(cellX, cellY) then

        Dim tmpCell as uByte = activeMap(cellX, cellY)

        if shotIndex <> 255 then

            if tmpCell = SPLITTER_INDEX then

                if (activeShots bxor TABLE_LOOKUP(@maskTable, shotIndex)) = 0 then 'Only one active shot?

                    activeShots = 7 '111, all three shots
                    tmpX = shots(shotIndex, 1)
                    tmpY = shots(shotIndex, 2)
                    tmpDir = shots(shotIndex, 3) 

                    if tmpDir = 1 then
                        shots(1,3) = 1
                        shots(2,3) = 3
                        shots(3,3) = 4
                    else if tmpDir = 2 then
                        shots(1,3) = 2
                        shots(2,3) = 3
                        shots(3,3) = 4
                    else if tmpDir = 3 then
                        shots(1,3) = 1
                        shots(2,3) = 2
                        shots(3,3) = 3
                    else if tmpDir = 4 then
                        shots(1,3) = 1
                        shots(2,3) = 2
                        shots(3,3) = 4
                    end if

                    shots(1,1) = tmpX
                    shots(2,1) = tmpX
                    shots(3,1) = tmpX

                    shots(1,2) = tmpY
                    shots(2,2) = tmpY
                    shots(3,2) = tmpY

                else

                    EXPLODE_SHOT(shotIndex)
                end if

                return

            end if
        
            if tmpCell >= DEFLECTORA_INDEX then
            if tmpCell <= DEFLECTORD_INDEX then

            
                if tmpCell = DEFLECTORA_INDEX then
                    shots(shotIndex, 3) = TABLE_LOOKUP(@reflectDirsA, shots(shotIndex, 3))
                else if tmpCell = DEFLECTORB_INDEX then
                    shots(shotIndex, 3) = TABLE_LOOKUP(@reflectDirsB, shots(shotIndex, 3))
                else if tmpCell = DEFLECTORC_INDEX then
                    shots(shotIndex, 3) = TABLE_LOOKUP(@reflectDirsC, shots(shotIndex, 3))
                else
                    shots(shotIndex, 3) = TABLE_LOOKUP(@reflectDirsD, shots(shotIndex, 3))
                end if 

                if IS_DESTRUCTIBLE(cellX, cellY) then 
                    BrokenDeflectorEffect()
                    ClearGridCell(cellX, cellY, 1)
                    for tmpDir = 1 to MAX_DESTRUCTIBLES_COUNT
                        if destructibles(tmpDir, 1) = cellX then
                        if destructibles(tmpDir, 2) = cellY then
                            activeDestructibles = activeDestructibles bxor tmpDir
                            destructibles(tmpDir, 1) = 0
                            destructibles(tmpDir, 2) = 0
                            exit for
                        end if
                        end if
                    next tmpDir
                end if

                'shots(shotIndex, 3) = reflectDirs(tmpCell - DEFLECTORA_INDEX + 1, shots(shotIndex, 3))
                return

            end if
            end if

            if tmpCell >= HBARRIER_INDEX then 
            if tmpCell <= EXPLOSIONCRATER_INDEX + 8 then

                EXPLODE_SHOT(shotIndex)
                return

            end if
            end if 
            
            if tmpCell >= FORCEFIELD_INDEX then
            if tmpCell < BLOCKER_INDEX then

                EXPLODE_SHOT(shotIndex)
                return
            
            end if
            end if

        end if

        if tmpCell = BLOCKER_INDEX then

            ClearGridCell(cellX, cellY, 1)
            AddScore(5)

            if shotIndex <> 255 then 
                CrateDestroyedEffect()
                EXPLODE_SHOT(shotIndex)                
            end if

            return

        end if

        if tmpCell >= MINECRATE_INDEX then
        if tmpCell <= CLEARSHOTCRATE_INDEX then

            ClearGridCell(cellX, cellY, 1)

            if shotIndex <> 255 then 
                CrateDestroyedEffect()
                EXPLODE_SHOT(shotIndex)                
            end if

            AddScore(5)

            if tmpCell = MINECRATE_INDEX then

                INCREASE_MINES()

            else if tmpCell = BOMBCRATE_INDEX then

                INCREASE_BOMBS()

            else if tmpCell = BLOCKERCRATE_INDEX then

                INCREASE_BLOCKERS()

            else if tmpCell = CHARGEDSHOTCRATE_INDEX then

                INCREASE_CHARGEDSHOTS()

            else if tmpCell = FIRESHOTCRATE_INDEX then

                INCREASE_FIRESHOTS()

            else if tmpCell = CLEARSHOTCRATE_INDEX then

                INCREASE_CLEARSHOTS()

            end if

            return

        end if
        end if

        if tmpCell = RADIOTOWER_INDEX then
 
            ClearGridCell(cellX, cellY, 1)

            if shotIndex <> 255 then 
                BuildTankDestroyedEffect()            
                EXPLODE_SHOT(shotIndex) 
            end if
            
            activeTowers = activeTowers - 1

            if activeTowers = 0 then 

                for tmpX = 1 to 20
                    for tmpY = 1 to 20
                        if activeMap(tmpX, tmpY) = FORCEFIELD_INDEX then 
                            ClearGridCell(tmpX, tmpY, 0)
                        end if
                    next tmpY
                next tmpX

            end if

            return

        end if

        if tmpCell = MOTHERSHIP_INDEX then

            ClearGridCell(cellX, cellY, 1)

            if shotIndex <> 255 then
                EXPLODE_SHOT(shotIndex)
                BuildTankDestroyedEffect()
            end if

            for tmpCell = 1 to MAX_SHIP_COUNT

                if ships(tmpCell, 1) = cellX then
                if ships(tmpCell, 2) = cellY then

                    activeShips = activeShips bxor TABLE_LOOKUP(@maskTable, tmpCell)
                    AddScore(50)

                    if tmpCell = freezingShip then freezingShip = 1

                    return

                end if
                end if

            next tmpCell
            
        end if

        if tmpCell = HANGAR_INDEX then

            ClearGridCell(cellX, cellY, 1)

            if shotIndex <> 255 then
                EXPLODE_SHOT(shotIndex)
                BuildTankDestroyedEffect()
            end if

            for tmpCell = 1 to MAX_HANGAR_COUNT

                if hangars(tmpCell, 1) = cellX then
                if hangars(tmpCell, 2) = cellY then

                    activeHangars = activeHangars bxor TABLE_LOOKUP(@maskTable, tmpCell)
                    AddScore(75)

                    if tmpCell = freezingHangar then freezingHangar = 1

                    return

                end if
                end if

            next tmpCell
            
        end if

    end if

end sub

sub UpdateFire()

    if activeShots = 0 then

        if dir = 0 then
            if MultiKeys(KEYX)
                shots(1,1) = playerX
                shots(1,2) = 40
                shots(1,3) = 1
                activeShots = 1
                CheckShotItems(1, ((playerX >> 1) - MAP_X_OFFSET), (20 - MAP_Y_OFFSET))
            end if
        end if

    else

        Dim buc as byte
        Dim tmpX as byte
        Dim tmpY as byte
        Dim tmpDir as byte
        Dim tmpExplode as byte
        Dim tmpBounces as byte
        Dim tmpMask as uByte
        Dim tmpActive as uByte = activeShots

        for buc = 1 to 3

            tmpMask = TABLE_LOOKUP(@maskTable, buc)

            if tmpActive & tmpMask then  'x,y,dir,explodePhase
                
                tmpExplode = shots(buc, 4)

                if tmpExplode <> -1 then

                    tmpExplode = tmpExplode + 1

                    if tmpExplode = 4 then
                        tmpExplode = -1
                        activeShots = activeShots bxor tmpMask
                    end if

                    shots(buc, 4) = tmpExplode

                else

                    tmpX = shots(buc, 1)
                    tmpY = shots(buc, 2)
                    tmpDir = shots(buc, 3)

                    if tmpDir = 1 then                      'arriba
                        if tmpY <= 4 then 
                            EXPLODE_SHOT(buc)
                            tmpY = 4
                        else
                            tmpY = tmpY - 1
                        end if
                    else if tmpDir = 2 then                 'abajo
                        if tmpY >= 42 then 
                            EXPLODE_SHOT(buc)
                            tmpY = 42
                        else
                            tmpY = tmpY + 1
                        end if
                    else if tmpDir = 3 then                 'izquierda
                        if tmpX <= 2 then
                            EXPLODE_SHOT(buc)
                            tmpX = 2
                        else
                            tmpX = tmpX - 1
                        end if
                    else if tmpDir = 4 then
                        if tmpX >= 40 then
                            EXPLODE_SHOT(buc)
                            tmpX = 40
                        else
                            tmpX = tmpX + 1
                        end if
                    end if

                    shots(buc, 1) = tmpX
                    shots(buc, 2) = tmpY

                    if shots(buc, 4) = -1 then
                    if ((tmpX & 1) | (tmpY & 1)) = 0 then 
                        CheckShotItems(buc, ((tmpX >> 1) - MAP_X_OFFSET), ((tmpY >> 1) - MAP_Y_OFFSET))
                    end if
                    end if

                end if

            end if

        next buc

    end if

end sub

function Intersects(active as uByte, enemX as uByte, enemY as ubyte, xMin as ubyte, xMax as uByte, yMin as ubyte, yMax as ubyte) as ubyte

    if active then
    if enemX >= xMin then
    if enemX <= xMax then
    if enemY >= yMin then
    if enemY <= yMax then

        return 1

    end if
    end if
    end if
    end if
    end if

    return 0

end function

sub CheckShotUnits(DirectKill as ubyte, cellX as ubyte, cellY as ubyte, squareOffset as ubyte)

    Dim tmpMask as ubyte
    Dim buc as ubyte

    if not activeAliens and not activeTanks then return

    Dim xMin as ubyte = (((cellX - squareOffset) + MAP_X_OFFSET) << 1) - 1
    Dim xMax as ubyte = (((cellX + squareOffset) + MAP_X_OFFSET) << 1) + 1
    Dim yMin as ubyte = (((cellY - squareOffset) + MAP_Y_OFFSET) << 1) - 1
    Dim yMax as ubyte = (((cellY + squareOffset) + MAP_Y_OFFSET) << 1) + 1

    if activeAliens then

        for buc = 1 to MAX_ALIEN_COUNT

            tmpMask = TABLE_LOOKUP(@maskTable, buc)

            if activeAliens & tmpMask then

                 if Intersects(1, aliens(buc, 1), aliens(buc, 2), xMin, xMax, yMin, yMax) then

                    if DirectKill then
                        activeAliens = activeAliens bxor tmpMask
                        AddScore(10)
                    else
                        aliens(buc, 4) = 0
                    end if

                    continue for

                end if

            end if

        next buc

    end if                                

    if activeTanks then

        for buc = 1 to MAX_TANK_COUNT

            tmpMask = TABLE_LOOKUP(@maskTable, buc)

            if activeTanks & tmpMask then

                if tanks(buc, 1) <= xMax then
                if tanks(buc, 1) >= xMin then
                if tanks(buc, 2) <= yMax then
                if tanks(buc, 2) >= yMin then

                    if DirectKill then
                        activeTanks = activeTanks bxor tmpMask
                        AddScore(25)
                    else
                        tanks(buc, 4) = 0
                    end if

                    continue for

                end if
                end if
                end if
                end if
        
            end if

        next buc

    end if

end sub

sub CheckCursorAction(mapX as uByte, mapY as uByte)

    Dim tmpX as ubyte
    Dim tmpY as ubyte
    Dim buc as uByte
    Dim cnt as ubyte = 255
    Dim tmpMask as uByte

    if cursorTool = TOOL_NONE

        Dim tmpItem as uByte = activeMap(mapX, mapY)
        
        if not tmpItem then 
            return
        else if tmpItem = DEFLECTORA_INDEX then
            activeMap(mapX, mapY) = DEFLECTORB_INDEX
            tmpItem = 0
        else if tmpItem = DEFLECTORB_INDEX then
            activeMap(mapX, mapY) = DEFLECTORD_INDEX
            tmpItem = 0
        else if tmpItem = DEFLECTORD_INDEX then
            activeMap(mapX, mapY) = DEFLECTORC_INDEX
            tmpItem = 0
        else if tmpItem = DEFLECTORC_INDEX then
            activeMap(mapX, mapY) = DEFLECTORA_INDEX
            tmpItem = 0
        end if

        if tmpItem = 0 then
            SetTileChecked(activeMap(mapX, mapY), GetTileColor(mapX + MAP_X_OFFSET, mapY + MAP_Y_OFFSET), mapX + MAP_X_OFFSET, mapY + MAP_Y_OFFSET)
            DeflectorEffect()
        end if

    else if cursorTool = TOOL_MINE then

        if availableMines > 0 then

            if activeMap(mapX, mapY) = 0 then

                DECREASE_MINES()
                GridObject(MINE_INDEX, mapX, mapY)
                MinePlacedEffect()

            end if

        end if

    else if cursorTool = TOOL_BLOCKER then

        if availableBlockers > 0 then

            if activeMap(mapX, mapY) = 0 then

                DECREASE_BLOCKERS()
                GridObject(BLOCKER_INDEX, mapX, mapY)
                pathMap(mapY + 1, mapX + 1) = 0
                MinePlacedEffect()

            end if

        end if

    else if cursorTool = TOOL_BOMB then

        if availableBombs > 0 then

            DECREASE_BOMBS()
            BombEffect()

            CheckShotUnits(1, mapX, mapY, 1)

            for tmpY = mapY - 1 to mapY + 1
                for tmpX = mapX - 1 to mapX + 1
                    cnt = cnt + 1

                    if tmpX < 1  then continue for
                    if tmpY < 1  then continue for
                    if tmpX > 20  then continue for
                    if tmpX > 20  then continue for

                    CheckShotItems(255, tmpX, tmpY)
                    GridObject(EXPLOSIONCRATER_INDEX + cnt, tmpX, tmpY)

                    pathMap(tmpY + 1, tmpX + 1) = 0

                next tmpX
            next tmpY

        end if

    else if cursorTool = TOOL_CHARGEDSHOT then

        if availableChargedShots > 0 then

            DECREASE_CHARGEDSHOTS()
            SATShotEffect()

            CheckShotItems(255, mapX, mapY)
            CheckShotUnits(0, mapX, mapY, 0)

        end if

    else if cursorTool = TOOL_FIRESHOT then

        if availableFireShots > 0 then

            if activeMap(mapX, mapY) = 0 then

burn_fire:

                cnt = FindEmptyBit(activeFires)

                if cnt <= MAX_ACTIVE_FIRES then

                    activeFires = activeFires bxor TABLE_LOOKUP(@maskTable, cnt)
                    fires(cnt, 1) = mapX
                    fires(cnt, 2) = mapY
                    fires(cnt, 3) = FIRE_SPEED

                    DECREASE_FIRESHOTS()
                    SATShotEffect()
                    GridObject(FIRE_INDEX, mapX, mapY)
                    pathMap(mapY + 1, mapX + 1) = 0
                    CheckShotUnits(1, mapX, mapY, 0)

                end if

            else if activeMap(mapX, mapY) >= BUSH_INDEX and activeMap(mapX, mapY) <= TREES_INDEX then

                goto burn_fire

            end if

        end if

    else if cursorTool = TOOL_CLEARSHOT then

        if availableClearShots > 0 then

            if activeMap(mapX, mapY) <> MOTHERSHIP_INDEX then
            if activeMap(mapX, mapY) <> HANGAR_INDEX then
            if activeMap(mapX, mapY) <> FORCEFIELD_INDEX then
            if activeMap(mapX, mapY) <> RADIOTOWER_INDEX then

                DECREASE_CLEARSHOTS()
                SATShotEffect()
                ClearGridCell(mapX, mapY, 1)

            end if
            end if
            end if
            end if

        end if

    end if

end sub

Dim changingCursor as uByte = 0

sub UpdateCursor()

    Dim changed as ubyte = 0

    if MultiKeys(KEY1) then

        changed = 1
        cursorTool = TOOL_NONE
        
    else if MultiKeys(KEY2) then

        changed = 1
        cursorTool = TOOL_BLOCKER   

    else if MultiKeys(KEY3) then

        changed = 1
        cursorTool = TOOL_MINE

    else if MultiKeys(KEY4) then
        
        changed = 1
        cursorTool = TOOL_BOMB

    else if MultiKeys(KEY5) then

        changed = 1
        cursorTool = TOOL_CHARGEDSHOT

    else if MultiKeys(KEY6) then

        changed = 1
        cursorTool = TOOL_FIRESHOT

    else if MultiKeys(KEY7) then

        changed = 1
        cursorTool = TOOL_CLEARSHOT

    else if MultiKeys(KEYN) then
    
        if changingCursor = 0 then

            changed = 1
            cursorTool = cursorTool - 1
            if cursorTool > TOOL_CLEARSHOT then cursorTool = TOOL_CLEARSHOT
            changingCursor = 1

        end if
    
    else if MultiKeys(KEYM) then

        if changingCursor = 0 then

            changed = 1
            cursorTool = cursorTool + 1
            if cursorTool > TOOL_CLEARSHOT then cursorTool = TOOL_NONE
            changingCursor = 1

        end if

    else

        changingCursor = 0

    end if

    if changed then

        if cursorTool = TOOL_NONE then
            PrintString("NONE   ", CREATE_ATTRIB(7, 0, 1, 0), 24, 14)
        else if cursorTool = TOOL_BLOCKER then
            PrintString("BARRIER", CREATE_ATTRIB(7, 0, 1, 0), 24, 14)     
        else if cursorTool = TOOL_MINE then
            PrintString("MINE   ", CREATE_ATTRIB(7, 0, 1, 0), 24, 14)
        else if cursorTool = TOOL_BOMB then
            PrintString("BOMB   ", CREATE_ATTRIB(7, 0, 1, 0), 24, 14)
        else if cursorTool = TOOL_CHARGEDSHOT then
            PrintString("LASER  ", CREATE_ATTRIB(7, 0, 1, 0), 24, 14)
        else if cursorTool = TOOL_FIRESHOT then
            PrintString("FIRE   ", CREATE_ATTRIB(7, 0, 1, 0), 24, 14)
        else if cursorTool = TOOL_CLEARSHOT then
            PrintString("WIPE   ", CREATE_ATTRIB(7, 0, 1, 0), 24, 14)
        end if

    end if

    cursorFrames = cursorFrames - 1

    if cursorMoved = 0 or cursorFrames = 0 then

        if cursorX > 0 then
        if MultiKeys(KEYJ) then
            cursorX = cursorX - 1
            cursorMoved = 1
            cursorVisible = 1
            cursorFrames = CURSOR_SPEED
            goto CHECKCURSORFRAMES
        end if
        end if

        if cursorX < 19 then
        if MultiKeys(KEYL) then
            cursorX = cursorX + 1
            cursorMoved = 1
            cursorVisible = 1
            cursorFrames = CURSOR_SPEED
            goto CHECKCURSORFRAMES
        end if
        end if

        if cursorY > 0 then
        if MultiKeys(KEYI) then
            cursorY = cursorY - 1
            cursorMoved = 1
            cursorVisible = 1
            cursorFrames = CURSOR_SPEED
            goto CHECKCURSORFRAMES
        end if
        end if

        if cursorY < 19 then
        if MultiKeys(KEYK) then
            cursorY = cursorY + 1
            cursorMoved = 1
            cursorVisible = 1
            cursorFrames = CURSOR_SPEED
            goto CHECKCURSORFRAMES
        end if
        end if

        if MultiKeys(KEYSPACE) then
            CheckCursorAction(cursorX + 1, cursorY + 1)
            cursorMoved = 1
            cursorVisible = 1
            cursorFrames = CURSOR_SPEED
        else
            cursorMoved = 0
        end if

    else if AnyKey() <> 0 then
        cursorMoved = 0
    end if

CHECKCURSORFRAMES:

    if cursorFrames = 0 then
        cursorVisible = not cursorVisible
        cursorFrames = CURSOR_FRAMES
    end if

end sub

function LineOfSight(x as uinteger, y as uinteger) as ubyte

    Dim address as uinteger = @activeMap + ((x - 1) * 20) + y
    DIm buc as ubyte

    for buc = 1 to 19 - y
        if peek(address) = 0 or (peek(address) >= TOXICWASTE_INDEX and peek(address) <= FORCEFIELD_INDEX) then
            address = address + 1
        else
            return 0
        end if
    next buc

    return 1

end function

sub CheckShipGens ()

    if activeShips <> 0 then

        Dim buc as uByte
        Dim valU as uByte
        Dim valD as uByte
        Dim valL as uByte
        Dim valR as uByte
        Dim tmpX as uByte
        Dim tmpY as uByte
        Dim tmpDir as uByte

        for buc = 1 to MAX_SHIP_COUNT

            if activeShips & TABLE_LOOKUP(@maskTable, buc) then

                valU = 0
                valD = 0
                valL = 0
                valR = 0
                tmpDir = 0

                tmpX = ships(buc, 1)
                tmpY = ships(buc, 2)

                if tmpX > 1 then
                    valL = pathMap(tmpY + 1, tmpX)
                end if

                if tmpX < 20 then
                    valR = pathMap(tmpY + 1, tmpX + 2)
                end if

                if tmpY > 1 then
                    valU = pathMap(tmpY, tmpX + 1)
                end if

                if tmpY < 20 then
                    valD = pathMap(tmpY + 2, tmpX + 1)
                end if

                tmpX = 255

                if valL < tmpX and valL <> 0 and valL <> 255 then
                    tmpX = valL
                    tmpDir = 3
                end if

                if valR < tmpX and valR <> 0 and valR <> 255 then
                    tmpX = valR
                    tmpDir = 1
                end if

                if valU < tmpX and valU <> 0 and valU <> 255 then
                    tmpX = valU
                    tmpDir = 4
                end if

                if valD < tmpX and valD <> 0 and valD <> 255 then
                    tmpX = valD
                    tmpDir = 2
                end if

                ships(buc, 3) = tmpDir
                if ships(buc, 3) = 0 then ships(buc, 4) = SHIP_SPEED
                
            end if

        next buc

    end if

end sub

function CheckAlienPaths() as uByte

    Dim buc as uByte
    Dim valU as uByte
    Dim valD as uByte
    Dim valL as uByte
    Dim valR as uByte
    Dim tmpX as uByte
    Dim tmpY as uByte
    Dim tmpMask as uByte
    Dim currCell as uByte

    Dim teleport as ubyte = 0

    if activeAliens <> 0 then

        for buc = 1 to MAX_ALIEN_COUNT

            tmpMask = TABLE_LOOKUP(@maskTable, buc)

            if activeAliens & tmpMask then

                valU = 0
                valD = 0
                valL = 0
                valR = 0

                tmpX = (aliens(buc, 1) >> 1) - MAP_X_OFFSET
                tmpY = (aliens(buc, 2) >> 1) - MAP_Y_OFFSET

                currCell = pathMap(tmpY + 1, tmpX + 1)

                if currCell <> 0 and currCell <> 255 then

                    if tmpX > 1 then
                        valL = pathMap(tmpY + 1, tmpX)
                        if valL <> 0 and valU <> 255 then continue for
                    end if

                    if tmpX < 20 then
                        valR = pathMap(tmpY + 1, tmpX + 2)
                        if valR <> 0 and valU <> 255 then continue for
                    end if

                    if tmpY > 1 then
                        valU = pathMap(tmpY, tmpX + 1)
                        if valU <> 0 and valU <> 255 then continue for
                    end if

                    if tmpY < 20 then
                        valD = pathMap(tmpY + 2, tmpX + 1)
                        if valD <> 0 and valU <> 255 then continue for
                    end if

                end if

                activeAliens = activeAliens bxor tmpMask
                teleport = 1

            end if

        next buc

    end if

    return teleport

end function

sub AlienSearchPath()

    PlayAlienTalk()
    PlayComputerThink()
    PathFind(10, 20)
    PlayComputerThink()
    CheckShipGens()
    PlayAlienListen()

    if CheckAlienPaths() then

        PlayAlienTeleport()

    end if

    refreshMap = 1

end sub

sub NewPathTest()

    Dim tmpMask as uByte
    Dim buc as uByte

    if activeShips <> 0 then

        for buc = 1 to MAX_SHIP_COUNT

            tmpMask = TABLE_LOOKUP(@maskTable, buc)

            if activeShips & tmpMask then

                if ships(buc, 3) = 0 then

                    PathFind(10, 20)
                    CheckShipGens()
                    return

                end if

            end if

        next buc

    end if

end sub

sub UpdateAliens()

    if activeAliens = 0 then return

    alienFrame = alienFrame - 1

    if alienFrame <> 0 then return

    alienFrame = ALIEN_SPEED

    Dim buc as uByte
    Dim tmpExplode as byte
    Dim tmpX as byte
    Dim tmpY as byte
    Dim tmpDir as byte
    Dim tmpCellX as byte
    Dim tmpCellY as byte
    Dim tmpMask as uByte
    Dim tmpCellValue as uByte
    Dim tmpMine as uByte

    for buc = 1 to MAX_ALIEN_COUNT

        tmpMask = TABLE_LOOKUP(@maskTable, buc)

        if activeAliens band tmpMask then 

            'Movimiento del enemigo:
            tmpExplode = aliens(buc, 4)
            
            if tmpExplode <> -1 then

                tmpExplode = tmpExplode + 1

                if tmpExplode = 4 then
                    tmpExplode = -1
                    activeAliens = activeAliens bxor tmpMask
                    AddScore(10)
                end if

                aliens(buc, 4) = tmpExplode

            else

                
                tmpX = aliens(buc, 1)
                tmpY = aliens(buc, 2)
                tmpDir = aliens(buc, 3)
                
                if (tmpX & 1) = 0 and (tmpY & 1) = 0 then

                    tmpCellX = (tmpX >> 1) - MAP_X_OFFSET
                    tmpCellY = (tmpY >> 1) - MAP_Y_OFFSET

                    Dim currentWeight as uByte = pathMap(tmpCellY + 1, tmpCellX + 1)
                    Dim tmpWeight as uByte
                   
                    tmpDir = 0
                    
                    if currentWeight = 255 or currentWeight = 0 then goto search

                    'No comprobamos límites, nunca nos vamos a salir del mapa de caminos
                    'ya que contiene un borde con 0's

                    'izquierda
                    tmpWeight = pathMap(tmpCellY + 1, tmpCellX)
                    if tmpWeight < currentWeight then
                    if tmpWeight <> 0 then
                            currentWeight = tmpWeight
                            tmpDir = 1
                    end if
                    end if

cpderecha:
                    'derecha
                    tmpWeight = pathMap(tmpCellY + 1, tmpCellX + 2)
                    if tmpWeight < currentWeight then
                    if tmpWeight <> 0 then
                            currentWeight = tmpWeight
                            tmpDir = 2
                    end if
                    end if
cparriba:
                    'Arriba
                    tmpWeight = pathMap(tmpCellY, tmpCellX + 1)
                    if tmpWeight < currentWeight then
                    if tmpWeight <> 0 then
                            currentWeight = tmpWeight
                            tmpDir = 3
                    end if
                    end if

cpabajo:
                    'abajo
                    tmpWeight = pathMap(tmpCellY + 2, tmpCellX + 1)
                    if tmpWeight < currentWeight then
                    if tmpWeight <> 0 then
                            'print at 0,0; tmpWeight; "  "; tmpX ; "  "; tmpCellY + 1; "  "
                            currentWeight = tmpWeight
                            tmpDir = 4
                    end if
                    end if
                
                end if

                if tmpDir = 1 then
                    tmpCellX = tmpCellX - 1
                    tmpX = tmpX - 1
                else if tmpDir = 2 then
                    tmpCellX = tmpCellX + 1
                    tmpX = tmpX + 1
                else if tmpDir = 3 then
                    tmpCellY = tmpCellY - 1
                    tmpY = tmpY - 1
                else if tmpDir = 4 then
                    tmpCellY = tmpCellY + 1
                    tmpY = tmpY + 1
                else 

search:
                    AlienSearchPath()

                end if

                if activeMap(tmpCellX, tmpCellY) = MINE_INDEX then
                    aliens(buc, 4) = 0
                    ClearGridCell(tmpCellX, tmpCellY, 0)
                end if

                aliens(buc, 1) = tmpX
                aliens(buc, 2) = tmpY
                aliens(buc, 3) = tmpDir

                if tmpY = 42 then 
                    dead = 1
                else if aliens(buc, 4) = 0 then
                    KilledAlienEffect()
                end if

            end if
            
        end if

    next buc

end sub

function TestTankMine(CellX as uByte, CellY as uByte, Dir as uByte, TankIndex as uByte) as uByte

    if Dir = 1 then
        CellX = CellX + 1
    else if Dir = 2 then
        CellY = CellY + 1
    else if Dir = 3 then
        CellX = CellX - 1
    else if Dir = 4 then
        CellY = CellY - 1
    end if 

    if activeMap(CellX, CellY) = MINE_INDEX then

        BuildTankDestroyedEffect()
        ClearGridCell(CellX, CellY, 0)
        tanks(TankIndex, 4) = 0
        return 1

    end if

    return 0

end function

function CheckTankObstacle(obstacle as byte) as byte

    if (obstacle >= TOXICWASTE_INDEX and obstacle <= FLOOD_INDEX) or obstacle = FORCEFIELD_INDEX then return 0
    return obstacle

end function

sub UpdateTanks()

    if activeTanks = 0 then return

    tankFrame = tankFrame - 1

    if tankFrame <> 0 then return

    tankFrame = TANK_SPEED

    Dim buc as uByte
    Dim tmpExplode as byte
    Dim tmpX as byte
    Dim tmpY as byte
    Dim tmpDir as byte
    Dim tmpInverseDir as byte

    Dim tmpCellX as byte
    Dim tmpCellY as byte
    Dim tmpMask as uByte

    Dim upCellValue as ubyte
    Dim downCellValue as ubyte
    Dim leftCellValue as ubyte
    Dim rightCellValue as ubyte

    Dim dirs(4) as ubyte

    for buc = 1 to MAX_TANK_COUNT

        tmpMask = TABLE_LOOKUP(@maskTable, buc)

        if activeTanks band tmpMask then 

            tmpExplode = tanks(buc, 4)

            if tmpExplode <> -1 then

                tmpExplode = tmpExplode + 1

                if tmpExplode = 4 then

                    tmpExplode = -1
                    activeTanks = activeTanks bxor tmpMask
                    AddScore(25)

                end if

                tanks(buc, 4) = tmpExplode

            else

                tmpX = tanks(buc, 1)
                tmpY = tanks(buc, 2)
                tmpDir = tanks(buc, 3)

                tmpCellX = (tmpX >> 1) - MAP_X_OFFSET
                tmpCellY = (tmpY >> 1) - MAP_Y_OFFSET

                if tmpX + 1 >= playerX and tmpX - 1 <= playerX  then
                if LineOfSight((playerX >> 1) - MAP_X_OFFSET, tmpCellY) then
                    if FastRnd() <= tankProbability then
                        dead = 2
                        return
                    end if
                end if
                end if

                'movimientos tanke: gira en sentido de las agujas del reloj
                'Si queda bloqueado explota

                if (tmpX & 1) or (tmpY & 1) then

                    'Estamos en media celda, el movimiento continúa
                    if tmpDir = 1 then
                        tmpX = tmpX + 1
                    else if tmpDir = 2 then
                        tmpY = tmpY + 1
                    else if tmpDir = 3 then
                        tmpX = tmpX - 1
                    else if tmpDir = 4 then
                        tmpY = tmpY - 1
                    end if 

                else

                    if tmpCellX > 1 then leftCellValue = activeMap(tmpCellX - 1, tmpCellY) else leftCellValue = 255
                    if tmpCellX < 20 then rightCellValue = activeMap(tmpCellX + 1, tmpCellY) else rightCellValue = 255
                    if tmpCellY > 1 then upCellValue = activeMap(tmpCellX, tmpCellY - 1) else upCellValue = 255
                    if tmpCellY < 19 then downCellValue = activeMap(tmpCellX, tmpCellY + 1) else downCellValue = 255

                    rightCellValue = CheckTankObstacle(rightCellValue)
                    dirs(1) = rightCellValue
                    downCellValue = CheckTankObstacle(downCellValue)
                    dirs(2) = downCellValue
                    leftCellValue = CheckTankObstacle(leftCellValue)
                    dirs(3) = leftCellValue
                    upCellValue = CheckTankObstacle(upCellValue)
                    dirs(4) = upCellValue


                    if dirs(tmpDir) <> 0 and dirs(tmpDir) <> MINE_INDEX then

                        Dim freeDirs as uByte
                        freeDirs = 1
                        
                        if rightCellValue = 0 or rightCellValue = MINE_INDEX then
                            dirs(freeDirs) = 1
                            freeDirs = freeDirs + 1
                        end if

                        if downCellValue = 0 or downCellValue = MINE_INDEX then
                            dirs(freeDirs) = 2
                            freeDirs = freeDirs + 1
                        end if

                        if leftCellValue = 0 or leftCellValue = MINE_INDEX then
                            dirs(freeDirs) = 3
                            freeDirs = freeDirs + 1
                        end if

                        if upCellValue = 0 or upCellValue = MINE_INDEX then
                            dirs(freeDirs) = 4
                            freeDirs = freeDirs + 1
                        end if

                        freeDirs = freeDirs - 1

                        if freeDirs = 0 then

                            tanks(buc, 4) = 0
                            goto ENDTANKMOVE

                        end if

                        if tmpDir = 1 then 
                            tmpInverseDir = 3
                        else if tmpDir = 2 then
                            tmpInverseDir = 4
                        else if tmpDir = 3 then
                            tmpInverseDir = 1
                        else if tmpDir = 4 then
                            tmpInverseDir = 2
                        end if

                        tmpDir = dirs((FastRnd() mod freeDirs) + 1)

                        if tmpDir = tmpInverseDir then  tmpDir = dirs((FastRnd() mod freeDirs) + 1)

                    end if

                    if TestTankMine(tmpCellX, tmpCellY, tmpDir, buc) = 0 then

                        if tmpDir = 1 then
                            tmpX = tmpX + 1
                        else if tmpDir = 2 then
                            tmpY = tmpY + 1
                        else if tmpDir = 3 then
                            tmpX = tmpX - 1
                        else if tmpDir = 4 then
                            tmpY = tmpY - 1
                        end if 

                    else

                        goto ENDTANKMOVE

                    end if

                end if
        
                tanks(buc, 1) = tmpX
                tanks(buc, 2) = tmpY
                tanks(buc, 3) = tmpDir

                if tmpX + 1 >= playerX and tmpX - 1 <= playerX  then

                    tmpCellX = (tmpX >> 1) - MAP_X_OFFSET
                    tmpCellY = (tmpY >> 1) - MAP_Y_OFFSET

                    if LineOfSight((playerX >> 1) - MAP_X_OFFSET, tmpCellY) then
                        if FastRnd() <= tankProbability then
                            dead = 2
                            return
                        end if
                    end if

                end if

                ENDTANKMOVE:

            end if

        end if

    next buc

end sub

sub TestCollisions()    

    Dim buc as ubyte

    Dim tmpShot1XMin as Byte
    Dim tmpShot1YMin as Byte
    
    Dim tmpShot1XMax as Byte
    Dim tmpShot1YMax as Byte

    Dim tmpShot2XMin as Byte
    Dim tmpShot2YMin as Byte
    
    Dim tmpShot2XMax as Byte
    Dim tmpShot2YMax as Byte

    Dim tmpShot3XMin as Byte
    Dim tmpShot3YMin as Byte

    Dim tmpShot3XMax as Byte
    Dim tmpShot3YMax as Byte

    Dim activeShot1 as Byte
    Dim activeShot2 as Byte
    Dim activeShot3 as Byte

    Dim tmpEnemX as Byte
    Dim tmpEnemY as Byte

    Dim tmpMask as ubyte

    if activeShots then

        tmpShot1XMin = shots(1,1) - 1
        tmpShot1YMin = shots(1,2) - 1
        tmpShot1XMax = tmpShot1XMin + 2
        tmpShot1YMax = tmpShot1YMin + 2

        activeShot1 = (activeShots band 1) and shots(1,4) = -1

        tmpShot2XMin = shots(2,1) - 1
        tmpShot2YMin = shots(2,2) - 1
        tmpShot2XMax = tmpShot2XMin + 2
        tmpShot2YMax = tmpShot2YMin + 2

        activeShot2 = (activeShots band 2) and shots(2,4) = -1

        tmpShot3XMin = shots(3,1) - 1
        tmpShot3YMin = shots(3,2) - 1
        tmpShot3XMax = tmpShot3XMin + 2
        tmpShot3YMax = tmpShot3YMin + 2

        activeShot3 = (activeShots band 4) and shots(3,4) = -1

        if activeAliens then

            for buc = 1 to MAX_ALIEN_COUNT

                if activeAliens & TABLE_LOOKUP(@maskTable, buc) then

                    if aliens(buc, 4) = -1 then

                        tmpEnemX = aliens(buc, 1)
                        tmpEnemY = aliens(buc, 2)

                        if Intersects(activeShot1, tmpEnemX, tmpEnemY, tmpShot1XMin, tmpShot1XMax, tmpShot1YMin, tmpShot1YMax) then

                            aliens(buc, 4) = 0
                            activeShots = activeShots band 11111110b
                            KilledAlienEffect()
                            continue for

                        end if

                        if Intersects(activeShot2, tmpEnemX, tmpEnemY, tmpShot2XMin, tmpShot2XMax, tmpShot2YMin, tmpShot2YMax) then

                            aliens(buc, 4) = 0
                            activeShots = activeShots band 11111101b
                            KilledAlienEffect()
                            continue for

                        end if

                        if Intersects(activeShot3, tmpEnemX, tmpEnemY, tmpShot3XMin, tmpShot3XMax, tmpShot3YMin, tmpShot3YMax) then

                            aliens(buc, 4) = 0
                            activeShots = activeShots band 11111011b
                            KilledAlienEffect()
                            continue for

                        end if

                    end if

                end if 

            next buc

        end if

        if activeTanks then

            for buc = 1 to MAX_TANK_COUNT

                if activeTanks & TABLE_LOOKUP(@maskTable, buc) then

                    if tanks(buc, 4) = -1 then

                        tmpEnemX = tanks(buc, 1)
                        tmpEnemY = tanks(buc, 2)

                        if Intersects(activeShot1, tmpEnemX, tmpEnemY, tmpShot1XMin, tmpShot1XMax, tmpShot1YMin, tmpShot1YMax) then

                            tanks(buc, 4) = 0
                            activeShots = activeShots band 11111110b
                            BuildTankDestroyedEffect()
                            continue for

                        end if

                        if Intersects(activeShot2, tmpEnemX, tmpEnemY, tmpShot2XMin, tmpShot2XMax, tmpShot2YMin, tmpShot2YMax) then

                            tanks(buc, 4) = 0
                            activeShots = activeShots band 11111101b
                            BuildTankDestroyedEffect()
                            continue for

                        end if

                        if Intersects(activeShot3, tmpEnemX, tmpEnemY, tmpShot3XMin, tmpShot3XMax, tmpShot3YMin, tmpShot3YMax) then

                            tanks(buc, 4) = 0
                            activeShots = activeShots band 11111011b
                            BuildTankDestroyedEffect()
                            continue for

                        end if

                    end if

                end if 

            next buc

        end if


        buc = playerX - 1

        if activeShot1 then
        if 41 = tmpShot1YMin then
        if buc = tmpShot1XMin then

            dead = 3
            activeShots = activeShots band 11111110b
            return

        end if
        end if
        end if

        if activeShot2 then
        if 41 = tmpShot2YMin then
        if buc = tmpShot2XMin then

            dead = 3
            activeShots = activeShots band 11111101b
            return

        end if
        end if
        end if

        if activeShot3 then
        if 41 = tmpShot3YMin then
        if buc = tmpShot3XMin then

            dead = 3
            activeShots = activeShots band 11111011b
            return

        end if
        end if
        end if

    end if
    
end sub

sub UpdateShips()

    if activeShips = 0 then return

    Dim buc as uByte
    Dim tmpVal as uByte
    Dim tmpX as uByte
    Dim tmpY as uByte
    Dim tmpDir as uByte
    Dim shipIndex as uByte

    for buc = freezingShip to freezingShip + (MAX_SHIP_COUNT - 1)
    
        shipIndex = TABLE_LOOKUP(@shipIndexes, buc)

        if activeShips & TABLE_LOOKUP(@maskTable, shipIndex) then

            if ships(shipIndex, 4) > 0 then
                ships(shipIndex, 4) = ships(shipIndex, 4) - 1
            else

                if ships(shipIndex, 3) <> 0 then 'if not deactivated...

                    if AVAILABLE_SLOT(activeAliens, MAX_ALIEN_COUNT) then
    compute_alien_pos:
                        ships(shipIndex, 4) = SHIP_SPEED
                        tmpX = ships(shipIndex, 1)
                        tmpY = ships(shipIndex, 2)
                        tmpVal = ships(shipIndex, 3)
                    
                        if tmpVal = 1 then  'spawn derecha
                            tmpX = tmpX + 1
                            tmpDir = 2      'alien mueve derecha
                        else if tmpVal = 2 then 'abajo
                            tmpY = tmpY + 1
                            tmpDir = 4
                        else if tmpVal = 3 then
                            tmpX = tmpX - 1
                            tmpDir = 1
                        else if tmpVal = 4 then
                            tmpY = tmpY - 1
                            tmpDir = 3
                        end if

                        CREATE_ALIEN(tmpX, tmpY, tmpDir, tmpVal)

                        freezingShip = 1
                    else
                        freezingShip = shipIndex
                        return                                      'If a ship is ready to generate aliens but no free spot is available we freeze the generation timers
            
                    end if
                end if
            end if
        end if

    next buc

end sub

sub UpdateHangars()

    if activeHangars = 0 then return

    Dim buc as uByte
    Dim tmpX as uByte
    Dim tmpY as uByte
    Dim tmpDir as uByte
    Dim tmpVal as uByte
    Dim hangarIndex as uByte

    for buc = freezingHangar to freezingHangar + (MAX_HANGAR_COUNT - 1)
    
        hangarIndex = hangarIndexes(buc)

        if activeHangars & TABLE_LOOKUP(@maskTable, hangarIndex) then

            if hangars(buc, 4) > 0 then
                hangars(buc, 4) = hangars(hangarIndex, 4) - 1
            else
                if AVAILABLE_SLOT(activeTanks, MAX_TANK_COUNT) then
                    hangars(hangarIndex, 4) = HANGAR_SPEED
                    tmpX = hangars(hangarIndex, 1)
                    tmpY = hangars(hangarIndex, 2)
                    tmpDir = hangars(hangarIndex, 3)
                    
                    if tmpDir = 1 then  'spawn derecha
                        tmpX = tmpX + 1
                    else if tmpDir = 2 then 'abajo
                        tmpY = tmpY + 1
                    else if tmpDir = 3 then
                        tmpX = tmpX - 1
                    else if tmpDir = 4 then
                        tmpY = tmpY - 1
                    end if
                
                    CREATE_TANK(tmpX, tmpY, tmpDir, tmpVal)
                    freezingHangar = 1
                else
                    freezingHangar = hangarIndex
                    return                                      'If a hangar is ready to generate tank but no free spot is available we freeze the generation timers
                end if
            end if
        end if

    next buc

end sub

sub UpdateFires()

    if activeFires = 0 then return

    Dim buc as uByte
    Dim tmpX as uByte
    Dim tmpY as uByte
    Dim tmpVal as uByte
    Dim tmpMask as uByte
    Dim fireIndex as uByte

    for buc = 1 to MAX_ACTIVE_FIRES
    
        tmpMask = TABLE_LOOKUP(@maskTable, buc)

        if activeFires & tmpMask then

            tmpVal = fires(buc, 3)

            if tmpVal = 0 then

                activeFires = activeFires bxor tmpMask
                ClearGridCell(fires(buc, 1), fires(buc, 2), 1)
                FireOffEffect()
                return

            else

                tmpVal = tmpVal - 1
                fires(buc, 3) = tmpVal

            end if

        end if

    next buc

end sub

sub RefreshMap()

    Dim tmpX as uByte
    Dim tmpY as uByte
    Dim tmpI as uByte

    for tmpX = 1 to 20
        for tmpY = 1 to 20
            if activeMap(tmpX, tmpY) = 0 then
                ClearGridCell(tmpX, tmpY, 0)
            else
                GridObject(activeMap(tmpX, tmpY), tmpX, tmpY)

                if activeDestructibles <> 0 then

                    if activeMap(tmpX, tmpY) >= DEFLECTORA_INDEX
                    if activeMap(tmpX, tmpY) <= DEFLECTORD_INDEX

                        for tmpI = 1 to MAX_DESTRUCTIBLES_COUNT

                            if activeDestructibles band TABLE_LOOKUP(@maskTable, tmpI) then

                                if destructibles(tmpI, 1) = tmpX
                                if destructibles(tmpI, 2) = tmpY

                                    SetTileColor(tmpX + MAP_X_OFFSET, tmpY + MAP_Y_OFFSET, 67)
                                    exit for

                                end if
                                end if

                            end if 
    
                        next tmpI

                    end if
                    end if

                end if

            end if
        next tmpY
    next tmpX

end sub

sub PathFind(x as ubyte, y as ubyte)

    Dim ex as uByte = x
    Dim ey as uByte = y

    Dim tmpX as uByte
    Dim tmpY as uByte

    tmpX = ex
    tmpY = ey

    for tmpX = 1 to 22
        for tmpY = 1 to 22
            pathMap(tmpY, tmpX) = 0
        next tmpY
    next tmpX

    for tmpX = 1 to 20
        for tmpY = 1 to 20

            if activeMap(tmpX, tmpY) = 0 or (activeMap(tmpX, tmpY) >= FORCEFIELD_INDEX and activeMap(tmpX, tmpY) <= TREES_INDEX) or activeMap(tmpX, tmpY) = MINE_INDEX then
                pathMap(tmpY + 1, tmpX + 1) = 255
            else
                pathMap(tmpY + 1, tmpX + 1) = 0
            end if

        next tmpY
    next tmpX

asm

PROC
LOCAL pmap, worklist1, worklist2, save_sp
LOCAL calc_distance, step_loop, skip_left, skip_right, skip_up, skip_down, swap_lists
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; Calculate distance to all reachable cells from the given start cell (or
; up to 'max_step' steps removed from the start cell).
; 
; In: D,E = x,y-coordinates of start position
;     map-array: walls should have the value 0
;                empty cells should have the value 255
;
; Out: pmap-array is filled in:
;  - walls cells have value 0
;  - unreachable cells (or not reached within 'max_steps') have value 255
;  - the start cell is given the value '254-max_steps'
;  - other cells are given an increasingly bigger value depending
;    on the number of steps required to reach this cell
;   (So start and reachable cells are given values in range [1..254])

calc_distance:	; Copy map to helper map. Initially no cell is marked as
		; reachable (they all have value=255). Except for walls,
		; those have value=0.
		; An alternative is to work on the original map, and reset
		; all values!=0 back to 255 when a new distance-map needs
		; to be calculated.
		;exx
		;ld	hl,map
		;ld	de,pmap
		;ld	bc,map_size
		;ldir

        ld d, (ix - 1)
        ld e, (ix - 2)


		;exx			; d,e = x,y-coord of start position
        
        di
		ld	l,e		;;; can be removed if D,E input is swapped
		ld	h,0		; hl = y-coord
		ld	e,d
		ld	d,h		; de = x-coord

        ld c, l
        ld b, h


		add	hl,hl		; *2
		add	hl,hl		; *4
		add	hl,hl		; *8
		add	hl,hl		; *16
		
        add hl, bc      ;+1
        add hl, bc      ;+1
        add hl, bc      ;+1
        add hl, bc      ;+1, total 20
        add hl, bc      ;+1
        add hl, bc      ;+1, total 22

		add	hl,de
		ld	de,pmap
		add	hl,de		; address of the start cell in pmap

		ld	(save_sp),sp	; after this point we can't use 'normal'
		ld	sp,worklist1+2	;   stack operations anymore
		xor	a
		ld	(worklist1+3),a	; mark end of list
		ld	de,worklist2

		ld	a,255-max_steps	; step-counter, starts at 2 instead of 1!!
		ld	(hl),254-max_steps ; mark start cell

		; At this point
		;  A  = step-count = 2
		;  HL = address of start cell
		;  SP = address of next item in worklist1 (points to 0-byte
		;       because the initial list only contains the start cell
		;       and as an optimization we don't explicitly store that
		;	cell in the list)
		;  DE = worklist2 (newly reached cells will be stored here)
		;  BC not in use

step_loop	; at this point:
		;  SP = address of next item in worklist
		;  HL = address of current cell
		dec	hl		; left neighbor cell
		cp	(hl)		; (HL) <= A means:    (so not-carry)
		jr	nc,skip_left	;  -> already marked or a wall
		; new cell is reached, mark it and store it in the new worklist
		ld	(hl),a		; mark cell with step-counter
		ex	de,hl
		ld	(hl),e
		inc	hl
		ld	(hl),d		; store cell in new worklist
		inc	hl		; update to next free position in list
		ex	de,hl
skip_left
		inc	hl
		inc	hl		; right neighbor
		cp	(hl)
		jr	nc,skip_right
		ld	(hl),a
		ex	de,hl
		ld	(hl),e
		inc	hl
		ld	(hl),d
		inc	hl
		ex	de,hl
skip_right
		ld	bc,-map_width-1
		add	hl,bc		; up neighbor
		cp	(hl)
		jr	nc,skip_up
		ld	(hl),a
		ex	de,hl
		ld	(hl),e
		inc	hl
		ld	(hl),d
		inc	hl
		ex	de,hl
skip_up
		ld	bc,map_width*2	; if (map_width < 128) -> B=0, see below
		add	hl,bc		; down neighbor
		cp	(hl)
		jr	nc,skip_down
		ld	(hl),a
		ex	de,hl
		ld	(hl),e
		inc	hl
		ld	(hl),d
		inc	hl
		ex	de,hl
skip_down
		pop	hl		; hl = next item from worklist
		inc	h
		dec	h		; upper-byte != 0
		jr	nz,step_loop	;  -> end-of-list not yet reached

		ex	de,hl
		inc	hl
		ld	(hl),b		; mark end of next worklist (B=0)

		inc	a		; increase step count
		ld	de,worklist2
		ld	hl,worklist1
		bit	0,a
		jr	z,swap_lists	; Z/NZ depends on the initial step-count!
		ex	de,hl		; swap lists (depends on odd/even step count)
swap_lists	ld	sp,hl

		; at this point:
		;  SP = address of first item in the new worklist
		;  DE = address of next worklist (this list does not need to cleared)
		;  A  = step count
		pop	hl
		inc	h
		dec	h		; h == 0?
		jr	nz,step_loop

		; We've just switched to a new worklist, and we're already
		; at the end of that list (so list was empty). This means
		; that all reachable cells have been marked.
		ld	sp,(save_sp)	; restore stack pointer
        ;ret 
        jp end_path_proc
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




map_width	equ	22	; must be strictly smaller than 128
map_height	equ	22
map_size	equ	map_width * map_height
max_steps	equ	253	; must be odd (or else change Z/NZ condition below)
                                ; must be <= 253
min		equ	22	; min(map_width, map_height, max_steps)


W		equ	0	; wall
_		equ	255	; empty space

pmap EQU _pathMap.__DATA__ ; :		ds	map_size
worklist1:	ds	2*4*min
worklist2:	ds	2*4*min
save_sp		ds	2

end_path_proc:

ei

ENDP

end asm

end sub

sub PrintDigit(x as uByte, y as uByte, value as uByte)

    Dim realIndex as uByte
    if value > 9 then realIndex = PLUS_INDEX else realIndex = NUMBERS_INDEX + value
    SetTile(realIndex, tileColors(realIndex + 1), x, y)

end sub

sub ShowLogo(X as uByte, Y as uByte)
    
    Dim tmpX as uByte
    
    for tmpX = 0 to 31 step 4

        SetTile(LOGO_INDEX + tmpX, tileColors(LOGO_INDEX + tmpX + 1), (tmpX >> 2) + X, Y)
        SetTile(LOGO_INDEX + tmpX + 1, tileColors(LOGO_INDEX + tmpX + 2), (tmpX >> 2) + X, Y + 1)
        SetTile(LOGO_INDEX + tmpX + 2, tileColors(LOGO_INDEX + tmpX + 3), (tmpX >> 2) + X, Y + 2)
        SetTile(LOGO_INDEX + tmpX + 3, tileColors(LOGO_INDEX + tmpX + 4), (tmpX >> 2) + X, Y + 3)

    next tmpX

end sub




Dim highScores(10) as uInteger => { 4096, 4000, 3500, 3000, 2500, 2000, 1500, 1000, 500, 250 }
Dim initials(10) as string ' => { "GUS", "AGB", "CHX", "JRC", "SJO", "PCV", "MGA", "BRL", "SRC", "SMB" }
initials(1) = "GUS"
initials(2) = "AGB"
initials(3) = "CHX"
initials(4) = "JRC"
initials(5) = "SJO"
initials(6) = "PCV"
initials(7) = "MGA"
initials(8) = "BRL"
initials(9) = "SRC"
initials(10) = "SMB"


sub InputHighScore()

    ClearScreen(CREATE_ATTRIB(7, 0, 0, 0))

    Dim tmpX as uByte = 65
    Dim tmpY as uByte = 0

    Dim ints as string = ""

    PrintString("YOU GOT A HIGH SCORE!", CREATE_ATTRIB(6, 0, 1, 0), 6, 1)
    PrintString("ENTER YOUR INITIALS", CREATE_ATTRIB(7, 0, 1, 0), 7, 10)
    PrintString("-   -   -", CREATE_ATTRIB(7, 0, 1, 0), 12, 14)

    while MultiKeys(KEYZ) or MultiKeys(KEYX) or MultiKeys(KEYC) or MultiKeys(KEYV)
    end while

    while tmpY < 3

        PrintString(CHR$(tmpX), CREATE_ATTRIB(7, 0, 1, 0), tmpY * 4 + 12, 13)

        if MultiKeys(KEYZ) then
            tmpX = tmpX - 1
            if tmpX < 65 then tmpX = 122
        else if MultiKeys(KEYC) then
            tmpX = tmpX + 1
            if tmpX > 122 then tmpX = 65
        else if MultiKeys(KEYX) then
            tmpY = tmpY + 1
            ints = ints + CHR$(tmpX)
            tmpX = 65
        else if MultiKeys(KEYV) then
            if tmpY > 0 then 
                PrintString(" ", CREATE_ATTRIB(7, 0, 1, 0), tmpY * 4 + 12, 13)
                tmpX = 65
                tmpY = tmpY - 1
                ints = ints(0 to tmpY)
            end if
        end if

        while MultiKeys(KEYZ) or  MultiKeys(KEYX) or MultiKeys(KEYC) or MultiKeys(KEYV)
        end while
                
    end while
    
    tmpX = 10

    for tmpY = 9 to 1 step -1
        if score > highScores(tmpY) then
            tmpX = tmpY
        else
            exit for
        end if
    next tmpY

    if tmpX < 10 then
        for tmpY = 9 to tmpX step -1
            highScores(tmpY + 1) = highScores(tmpY)
            initials(tmpY + 1) = initials(tmpY)
        next tmpY
    end if

    highScores(tmpX) = score
    initials(tmpX) = ints

end sub

sub ShowScores()

    ClearScreen(CREATE_ATTRIB(7, 0, 0, 0))

    PrintString("HIGH SCORES", CREATE_ATTRIB(6, 0, 1, 0), 10, 1)
    
    Dim tmpString as string
    
    Dim tmpX as uByte
    Dim tmpY as uByte
    Dim tmpZ as uByte

    Dim tmpScore as uInteger

    for tmpX = 1 to 10

        /'
        tmpString = STR$(highScores(tmpX))
        while len(tmpString) < 5
            tmpString = "0" + tmpString
        end while
        '/
        tmpString = ""
        tmpScore = highScores(tmpX)

        for tmpY = 1 to 5
        
            tmpZ = tmpScore mod 10
            tmpScore = tmpScore / 10
            tmpString = chr$(tmpZ + 48) + tmpString

        next tmpY

        PrintString(initials(tmpX), CREATE_ATTRIB(7, 0, 1, 0), 4, tmpX * 2 + 2)
        PrintString("................", CREATE_ATTRIB(7, 0, 1, 0), 7, tmpX * 2 + 2)
        PrintString(tmpString, CREATE_ATTRIB(7, 0, 1, 0), 23, tmpX * 2 + 2)

        'print at tmpX * 2 + 2, 4; initials(tmpX);"................"; tmpString

    next tmpX

end sub




function ShowMainMenu() as uByte

    ClearScreen(CREATE_ATTRIB(7,0,0, 0))

    PlayIntro()

'    InitMusic()
'    PlayMusic()

show_menu:

    ClearScreen(CREATE_ATTRIB(7,0,0, 0))

    ShowLogo(12, 0)
    
    PrintString("THE BAD GUYS", CREATE_ATTRIB(2, 0, 1, 0), 3, 5)

    Draw1x1Sprite(ENEMA_INDEX, 4, 14)
    PrintString("ALIEN", 7, 4, 7)
    Draw1x1Sprite(TANKV_INDEX, 4, 18)
    PrintString("TANK", 7, 4, 9)

    PrintString("YOUR UNITS", CREATE_ATTRIB(4, 0, 1, 0), 4, 17)

    Draw1x1Sprite(PLAYER_INDEX, 4, 38)
    PrintString("DRONE", 7, 4, 19)
    Draw1x1Sprite(CURSOR_INDEX, 4, 42)
    PrintString("SAT TARGET", 7, 4, 21)



    SetTile(MOTHERSHIP_INDEX, tileColors(MOTHERSHIP_INDEX + 1), 2, 11)
    PrintString("MOTHERSHIP", 7, 4, 11)

    SetTile(HANGAR_INDEX, tileColors(HANGAR_INDEX + 1), 2, 13)
    PrintString("HANGAR", 7, 4, 13)

    SetTile(RADIOTOWER_INDEX, tileColors(RADIOTOWER_INDEX + 1), 2, 15)
    PrintString("ENERGY TOWER", 7, 4, 15)

    RenderFrame()
    CancelOps()
    

    PrintString("SUPPLIES", CREATE_ATTRIB(5, 0, 1, 0), 20, 5)

    SetTile(BLOCKERCRATE_INDEX, tileColors(BLOCKER_INDEX + 1), 17, 7)
    PrintString("BLOCK", 7, 18, 7)
    SetTile(MINECRATE_INDEX, tileColors(MINE_INDEX + 1), 25, 7)
    PrintString("MINE", 7, 26, 7)

    SetTile(BOMBCRATE_INDEX, tileColors(BOMB_INDEX + 1), 17, 9)
    PrintString("BOMB", 7, 18, 9)
    SetTile(CHARGEDSHOTCRATE_INDEX, tileColors(CHARGEDSHOT_INDEX + 1), 25, 9)
    PrintString("LASER", 7, 26, 9)

    SetTile(FIRESHOTCRATE_INDEX, tileColors(FIRESHOT_INDEX + 1), 17, 11)
    PrintString("FIRE", 7, 18, 11)
    SetTile(CLEARSHOTCRATE_INDEX, tileColors(CLEARSHOT_INDEX + 1), 25, 11)
    PrintString("WHIPE", 7, 26, 11)

    PrintString("OBSTACLES", CREATE_ATTRIB(6, 0, 1, 0), 20, 13)

    SetTile(DEFLECTORA_INDEX, tileColors(DEFLECTORA_INDEX + 1), 17, 15)
    PrintString("DEF.", 7, 18, 15)
    SetTile(FORCEFIELD_INDEX, tileColors(FORCEFIELD_INDEX + 1), 25, 15)
    PrintString("F.FLD", 7, 26, 15)

    SetTile(SMALLBUILDING_INDEX, tileColors(SMALLBUILDING_INDEX + 1), 17, 17)
    PrintString("BUILD", 7, 18, 17)
    SetTile(TREES_INDEX, tileColors(TREES_INDEX + 1), 25, 17)
    PrintString("TREES", 7, 26, 17)

    SetTile(FLOOD_INDEX, tileColors(FLOOD_INDEX + 1), 17, 19)
    PrintString("FLOOD", 7, 18, 19)
    SetTile(FIRE_INDEX, tileColors(FIRE_INDEX + 1), 25, 19)
    PrintString("FIRE", 7, 26, 19)

    PrintString("AND MORE...", CREATE_ATTRIB(3, 0, 1, 0), 19, 21)

    PrintString("SPC=START I=INSTRUCTIONS C=CODE", CREATE_ATTRIB(7, 0, 1, 0), 1, 23)
    
    frameCounter = 0

    while 1

        if MultiKeys(KEYSPACE) then
            return 0
        else if MultiKeys(KEYI) then
            return 1
        else if MultiKeys(KEYC) then
            return 2
        else if frameCounter > 600

            
            frameCounter = 0
            ShowScores()
            while frameCounter < 300 and not MultiKeys(KEYSPACE)
            end while

            goto show_menu

        end if

    end while

    ClearScreen(CREATE_ATTRIB(7,0,0, 0))

  '  StopMusic()

end function

sub ShowInstructions()

    PrintString("-INSTRUCTIONS-", CREATE_ATTRIB(6, 0, 1, 0), 9, 0)
    
    PrintString("Objective:", CREATE_ATTRIB(5, 0, 1, 0), 0, 3)
    PrintString("Clear the screen of any enemy", CREATE_ATTRIB(7, 0, 1, 0), 0, 4)
    PrintString("units using your drone and the", CREATE_ATTRIB(7, 0, 1, 0), 0, 5)
    PrintString("S.A.T. system.", CREATE_ATTRIB(7, 0, 1, 0), 0, 6)
    
    PrintString("Controls:", CREATE_ATTRIB(5, 0, 1, 0), 0, 8)
    PrintString("Move your drone with Z/X, fire", CREATE_ATTRIB(7, 0, 1, 0), 0, 9)
    PrintString("with C, self-destruct with 0.", CREATE_ATTRIB(7, 0, 1, 0), 0, 10)
    PrintString("Move the S.A.T. cursor with", CREATE_ATTRIB(7, 0, 1, 0), 0, 11)
    PrintString("IKJL and fire with space.", CREATE_ATTRIB(7, 0, 1, 0), 0, 12)
    PrintString("Choose a S.A.T. tool with 1-7.", CREATE_ATTRIB(7, 0, 1, 0), 0, 13)

    PrintString("For detailed instructions read", CREATE_ATTRIB(6, 0, 1, 0), 0, 17)
    PrintString("the game manual.", CREATE_ATTRIB(6, 0, 1, 0), 0, 18)

    PrintString("PRESS SPACE TO CONTINUE...", CREATE_ATTRIB(7, 0, 1, 0), 0, 23)
    

    while not MultiKeys(KEYSPACE)
    end while

end sub

function EnterCode() as uByte

    ClearScreen(CREATE_ATTRIB(7, 0, 0, 0))

    Dim tmpX as uByte = 65
    Dim tmpY as uByte = 0

    Dim ints as string = ""

    PrintString("ENTER YOUR CODE", CREATE_ATTRIB(6, 0, 1, 0), 8, 1)
    PrintString("- - - - -", CREATE_ATTRIB(7, 0, 1, 0), 11, 14)

    while MultiKeys(KEYZ) or MultiKeys(KEYX) or MultiKeys(KEYC) or MultiKeys(KEYV)
    end while

    while tmpY < 5

        PrintString(CHR$(tmpX), CREATE_ATTRIB(7, 0, 1, 0), tmpY * 2 + 11, 13)

        while AnyKey() = 0
        end while

        if MultiKeys(KEYZ) then
            tmpX = tmpX - 1
            if tmpX < 65 then tmpX = 80
        else if MultiKeys(KEYC) then
            tmpX = tmpX + 1
            if tmpX > 80 then tmpX = 65
        else if MultiKeys(KEYX) then
            tmpY = tmpY + 1
            ints = ints + CHR$(tmpX)
            tmpX = 65
        else if MultiKeys(KEYV) then
            if tmpY > 0 then 
                PrintString(" ", CREATE_ATTRIB(7, 0, 1, 0), tmpY * 2 + 11, 13)
                tmpX = 65
                tmpY = tmpY - 1
                ints = ints(0 to tmpY)
            end if
        end if

        while MultiKeys(KEYZ) or  MultiKeys(KEYX) or MultiKeys(KEYC) or MultiKeys(KEYV)
        end while
                
    end while

    while AnyKey()
    end while
    
    if DecodeKey(ints, level, lifes) = 0 or lifes > 4 or lifes < 1 or level < 2 or level > 20  then

        PrintString("INVALID CODE", CREATE_ATTRIB(2, 0, 1, 0), 10, 18)

        while not AnyKey()
        end while

        return 0

    end if

    return 1

end function

InitGraphics()

main:

Dim buc as uByte
Dim tmpLoop as ubyte

tmpLoop = 1

for buc = 1 to MAX_SHIP_COUNT * 2

    shipIndexes(buc) = tmpLoop
    tmpLoop = tmpLoop + 1
    if tmpLoop > MAX_SHIP_COUNT then tmpLoop = 1

next buc

tmpLoop = 1

for buc = 1 to MAX_HANGAR_COUNT * 2

    hangarIndexes(buc) = tmpLoop
    tmpLoop = tmpLoop + 1
    if tmpLoop > MAX_HANGAR_COUNT then tmpLoop = 1

next buc

buc = ShowMainMenu()

ClearScreen(CREATE_ATTRIB(7,0,0, 0))

if buc = 1 then
    ShowInstructions()
    goto main
end if

lifes = 4
score = 0
level = 1

if buc = 2 then

    if EnterCode() = 0 then goto main

end if

init_level:

PlayLevel(level)
InitInterface()
DrawGrid()
InitLevel()

while(1)

    frameCounter = 0

    UpdateCursor()
    UpdateAliens()
    UpdateTanks()
    UpdateShips()
    UpdateHangars()
    UpdatePlayer()
    UpdateFire()
    TestCollisions()
    UpdateFires()

    if refreshMap then
        refreshMap = 0
        RefreshMap()
    end if

    Draw1x1Sprite(playerSprite, playerX, 42)

    if activeShots <> 0 then

        for buc = 1 to 3
            
            if activeShots & TABLE_LOOKUP(@maskTable, buc) then

                if shots(buc, 4) <> -1 then
                    Draw1x1Sprite(shots(buc, 4) + EXPLODEA_INDEX, shots(buc, 1), shots(buc, 2))
                else
                    if shots(buc, 3) < 3 then
                         if shots(buc, 2) & 1 then 
                            Draw1x1Sprite(VFIREA_INDEX, shots(buc, 1), shots(buc, 2))
                        else
                            Draw1x1Sprite(VFIREB_INDEX, shots(buc, 1), shots(buc, 2))
                        end if
                    else
                        if shots(buc, 1) & 1 then 
                            Draw1x1Sprite(HFIREA_INDEX, shots(buc, 1), shots(buc, 2))
                        else
                            Draw1x1Sprite(HFIREB_INDEX, shots(buc, 1), shots(buc, 2))
                        end if
                    end if
                end if

            end if

        next buc

    end if

    if cursorVisible then
        Draw1x1Sprite(CURSOR_INDEX, 2 + (cursorX << 1), 4 + (cursorY << 1))
    end if

    if activeAliens <> 0 then

        for buc = 1 to MAX_ALIEN_COUNT

            if activeAliens & TABLE_LOOKUP(@maskTable, buc) then

                if aliens(buc, 4) <> -1 then
                    Draw1x1Sprite(aliens(buc, 4) + EXPLODEA_INDEX, aliens(buc, 1), aliens(buc, 2))
                else

                    if aliens(buc, 1) & 1 then 
                        Draw1x1Sprite(ENEMB_INDEX, aliens(buc, 1), aliens(buc, 2))
                    else
                        Draw1x1Sprite(ENEMA_INDEX, aliens(buc, 1), aliens(buc, 2))
                    end if

                end if

            end if
    
        next buc

    end if

    if activeTanks <> 0 then

        for buc = 1 to MAX_TANK_COUNT

            if activeTanks & TABLE_LOOKUP(@maskTable, buc) then

                if tanks(buc, 4) <> -1 then
                    Draw1x1Sprite(tanks(buc, 4) + EXPLODEA_INDEX, tanks(buc, 1), tanks(buc, 2))
                else

                    if tanks(buc, 3) & 1 then 
                        Draw1x1Sprite(TANKH_INDEX, tanks(buc, 1), tanks(buc, 2))
                    else
                        Draw1x1Sprite(TANKV_INDEX, tanks(buc, 1), tanks(buc, 2))
                    end if

                end if

            end if
    
        next buc

    end if

    RenderFrame()

    if updateScore then
        updateScore = 0
        PrintPaddedNumber(24, 11, score, 6)
    end if

    if dead <> 0 then

        if dead = 1 then
            PlayDeathAlien()
        else if dead = 2 then
            PlayDeathTank()
        else
            PlayDeathShot()
        end if

        'lifes = lifes - 1

        if lifes = 0 then

            PlayShowText(GAMEOVER_INDEX)

            DoPause(140)

            if score > highScores(10) then

                InputHighScore()

            end if

            goto main

        end if

        ShowLifes()
        DrawGrid()
        InitLevel()

    else if activeAliens = 0 then
        if activeTanks = 0 then
        if activeShips = 0 then
        if activeHangars = 0 then
        if activeTowers = 0 then
nextLevel:
            score = score + lifes * level
            updateScore = 1

            PlayShowText(GRIDCLEAR_INDEX)

            if level < 20 then

                level = level + 1
    
                PrintString("CODE: " + GenerateKey(level,lifes), CREATE_ATTRIB(7, 0, 1, 0), 11, 21)
                PrintString("PRESS SPACE  TO CONTINUE", CREATE_ATTRIB(7, 0, 1, 0), 4, 23)

                while AnyKey() = 0
                end while

                goto init_level
            else

                DoPause(140)

                PlayEnding()
                goto main
            end if

        end if
        end if
        end if
        end if
    else if MultiKeys(KEYY) then
        goto nextLevel
    end if

    while frameCounter < 2
    end while
    

end while

